---
title: 数据库范式
order: 2
category:
  - MySQL
tag: []
author: H·T·L
date: 2024-07-25
permalink: /03-Java/MySQL/vh9ncgxw/
---
### 第一范式

###### **无重复的列**

数据库表的**每一列都是不可分割的原子数据项**，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性

在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。 [1] 

### 第二范式

###### **属性完全依赖于主键**

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。

当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。

如果存在不符合第二范式的情况，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。 [1] 

### 第三范式

###### **属性不能传递依赖于主属性（属性不依赖于其它非主键属性）**

第三范式（3NF）是在第二范式（2NF）的基础上建立起来的，即满足第三范式（3NF）必须先满足第二范式（2NF）。

如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。

下面以一个学校的学生系统为例分析说明这几个范式的应用。首先我们确定一下要设计的内容包括那些。学号、姓名、年龄、性别、电话、系别、系办地址、系办电话、课程、学分、成绩，等信息。 [1] 



### BCNF

###### 针对某一列与复合主键中的某一列有关，而与其他主键无关

所谓BCNF，是指在第三范式的基础上进一步消除主属性对于码的部分函数依赖和传递依赖。BCNF需要符合3NF，并且，主属性不依赖于主属性。

假设仓库管理关系表为StorehouseManage(仓库ID,存储物品ID,管理员ID,数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：

　　(仓库ID,存储物品ID) →(管理员ID,数量)

　　(管理员ID,存储物品ID) → (仓库ID,数量)

　　所以，(仓库ID,存储物品ID)和(管理员ID,存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：

　　(仓库ID) → (管理员ID)

　　(管理员ID) → (仓库ID)

　　即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。它会出现如下异常情况：

　　(1) 删除异常：

　　当仓库被清空后，所有"存储物品ID"和"数量"信息被删除的同时，"仓库ID"和"管理员ID"信息也被删除了。

　　(2) 插入异常：

　　当仓库没有存储任何物品时，无法给仓库分配管理员。

　　(3) 更新异常：

　　如果仓库换了管理员，则表中所有行的管理员ID都要修改。

　　把仓库管理关系表分解为二个关系表：

　　仓库管理：StorehouseManage(仓库ID,管理员ID)；

　　仓库：Storehouse(仓库ID,存储物品ID,数量)。

这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。

### 第四范式

###### 限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。

对于第四范式，从理论层面来讲是，关系模式R∈1NF,如果对于R对于R的每个非平凡多值依赖X→→Y(Y不属于X),X都含有候选码，则R∈4NF。4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。显然一个关系模式是4NF，则必为BCNF。

也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值。若有多值就违反了第四范式。

有这样一个用户联系方式表TELEPHONE(CUSTOMERID,PHONE,CELL)。CUSTOMERID为用户ID,PHONE为用户的固定电话,CELL为用户的移动电话。

本来，这是一个非常简单的第3范式表。主键为CUSTOMERID，不存在传递依赖。但在某些情况下，这样的表还是不合理的。比如说，用户有两个固定电话，两个移动电话。这时，表的具体表示如下：

CUSTOMERID PHONE CELL

1000 8828-1234 149088888888

1000 8838-1234 149099999999

由于PHONE和CELL是互相独立的，而有些用户又有两个和多个值。这时此表就违反第四范式。

在这种情况下，此表的设计就会带来很多维护上的麻烦。例如，如果用户放弃第一行的固定电话和第二行的移动电话，那么这两行会合并吗？等等

解决问题的方法为，设计一个新表NEW_PHONE(CUSTOMERID,NUMBER,TYPE).这样就可以对每个用户处理不同类型的多个电话号码，而不会违反第四范式。

显然，第四范式的应用范围比较小，因为只有在某些特殊情况下，要考虑将表规范到第四范式。所以在实际应用中，一般不要求表满足第四范式。



### 5NF（第五范式）

第五范式（5NF）：是最终范式。消除了4NF中的连接依赖。

第五范式有以下要求：

（1）必须满足第四范式

（2）表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。

第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。

有一个销售信息表SALES（SALEPERSON，VENDOR，PRODUCT）。SALEPERSON代表销售人员，VENDOR代表供和商，PRODUCT则代表产品。

在某些情况下，这个表中会产生一些冗余。可以将表分解为PERSON_VENDOR表（SALEPERSON，VENDOR）；PERSON_PRODUCT表（SALEPERSON，PRODUCT）；VENDOR­_PRODICT表（VENDOR，PRODUCT）